/// ### From Best Effort to Causal Order Reliable Broadcast
///{"gradingToken":[45,45,45,45,45,66,69,71,73,78,32,80,71,80,32,77,69,83,83,65,71,69,45,45,45,45,45,10,86,101,114,115,105,111,110,58,32,66,67,80,71,32,118,49,46,53,53,10,10,104,81,73,77,65,57,79,116,77,118,84,69,98,74,49,102,65,82,65,65,116,70,89,115,66,80,48,48,69,50,57,53,113,118,110,87,57,80,48,52,71,51,90,82,65,77,101,72,97,76,56,71,104,120,56,86,68,70,108,48,102,117,83,122,10,106,106,88,107,113,117,83,121,112,104,48,90,71,57,72,57,84,108,103,50,99,78,85,77,120,53,66,74,73,65,78,90,74,109,122,55,105,71,71,99,78,49,71,121,75,101,116,77,71,66,49,47,114,81,68,116,81,68,89,57,73,108,90,79,10,47,101,108,109,52,119,67,88,108,57,76,102,107,105,67,66,106,88,109,72,87,120,103,72,70,114,103,86,49,76,86,88,49,77,47,57,56,88,115,119,65,100,108,80,82,111,85,75,69,121,109,109,97,105,50,50,104,48,50,112,105,117,98,120,10,111,57,107,72,88,120,79,54,85,83,65,88,121,118,112,118,112,113,81,72,67,43,90,71,120,79,97,88,81,113,113,83,85,103,68,68,89,50,106,74,75,53,55,55,56,69,77,47,69,98,111,85,70,107,47,115,53,120,107,110,72,113,98,106,10,67,105,111,54,84,87,86,113,120,118,81,85,67,53,118,48,99,54,90,119,49,97,113,99,122,98,78,98,75,100,113,89,71,81,73,67,106,105,74,55,66,101,115,79,55,90,43,107,78,77,89,48,49,48,70,101,109,84,102,110,52,121,104,115,10,77,74,68,97,83,75,114,84,86,67,82,76,87,90,66,51,122,69,122,106,121,120,115,117,71,74,101,48,105,106,54,107,88,118,110,99,84,53,68,75,68,83,81,112,82,79,108,68,110,47,81,87,76,112,49,116,50,87,68,113,79,70,73,84,10,67,109,104,81,122,76,78,107,100,88,55,74,49,81,86,106,56,89,85,78,54,47,113,49,106,98,104,101,81,77,48,71,84,82,53,88,56,76,117,48,76,121,57,102,111,117,71,103,117,73,77,115,77,120,88,109,84,82,82,84,48,76,97,50,10,109,89,107,108,103,56,102,55,87,66,67,82,76,65,90,113,78,81,122,88,75,109,85,119,78,49,122,89,118,118,118,106,69,55,106,104,43,107,81,101,112,110,47,105,76,80,97,71,67,111,78,81,79,112,99,112,54,104,115,121,112,74,98,97,10,69,88,107,109,57,47,48,68,43,114,98,89,104,65,75,119,47,116,86,68,109,48,48,74,97,89,122,107,77,100,84,121,49,120,69,51,105,48,89,107,106,48,74,88,101,121,88,109,51,70,99,107,121,43,102,114,106,43,107,90,103,121,56,89,10,86,74,117,87,71,73,78,70,70,118,43,67,79,102,67,66,98,114,86,85,104,89,78,85,49,109,122,51,73,98,53,69,113,57,112,76,82,98,86,79,67,47,48,105,97,88,104,70,110,69,120,79,107,81,100,109,54,121,112,48,118,98,51,79,10,54,118,76,73,111,77,47,48,98,53,102,117,100,73,109,89,82,115,70,69,87,47,50,97,84,57,107,72,97,70,47,81,65,106,79,50,105,80,121,97,66,85,116,55,52,48,108,109,70,80,78,67,106,114,56,116,111,115,86,110,117,81,72,83,10,119,70,52,66,108,57,119,103,97,109,74,108,106,114,117,122,82,80,122,76,69,104,121,73,116,86,100,110,56,50,55,103,78,76,80,111,71,77,104,47,84,78,65,52,113,51,98,122,100,116,50,76,106,100,77,48,118,65,55,71,75,114,116,54,10,52,122,120,75,49,119,65,98,48,112,85,75,89,107,118,86,110,70,109,110,118,79,114,112,120,107,50,109,73,119,52,83,72,98,115,109,67,83,121,66,105,47,110,121,106,97,72,56,78,116,76,49,86,111,100,51,81,73,118,70,98,117,112,97,10,115,85,67,80,72,97,70,77,85,107,112,56,65,79,116,121,50,115,81,112,109,77,119,89,50,90,82,81,84,70,56,100,54,55,78,117,48,80,76,50,115,53,104,50,84,101,103,82,99,106,52,69,80,84,75,114,71,52,105,98,106,53,49,88,10,105,111,108,86,122,47,118,49,66,56,54,68,73,102,87,109,99,78,76,87,90,51,117,43,68,75,51,114,51,118,57,106,116,68,53,70,105,89,57,82,48,47,104,120,86,108,83,106,53,115,120,75,103,101,115,73,67,70,100,77,112,102,48,74,10,98,80,112,117,97,71,111,109,110,74,113,67,68,107,66,71,52,120,74,74,106,119,76,78,108,86,83,76,103,114,106,80,101,67,85,76,67,101,66,81,115,75,102,97,80,83,99,88,53,115,99,49,78,52,82,86,115,105,116,118,105,73,85,51,10,121,85,109,52,53,104,98,118,87,74,57,84,87,57,84,55,102,121,105,67,49,74,74,49,67,47,87,76,111,73,52,47,53,101,67,50,115,112,111,97,48,56,120,115,49,69,54,57,77,107,106,97,113,89,103,57,89,117,117,70,87,115,110,88,10,61,66,54,103,66,10,45,45,45,45,45,69,78,68,32,80,71,80,32,77,69,83,83,65,71,69,45,45,45,45,45,10]}

/// This is the first programming assignment where you will have to build and reuse multiple components.  
/// Starting bottom-up, you will first have to implement _best effort broadcast_, then _reliable broadcast_ and finally _causal order reliable broadcast_.  
/// Mind that passing each component check will give you a **partial** grade and therefore you will need to pass **all** checks to get the full grade for this programming assignment.

/// **Things to Remember**:  
/// 1. Some components such as `PerfectLink`, `Network` and `Timer` are already provided. No need to implement them.  
/// 2. Execute the imports defined below **before** compiling your component implementations.  
/// 3. We recommend making use of the component state and internal messages we have provided, if any, to complete the implementation logic.  
/// 4. You can always print messages to the output log, from within handlers to see what happens during the simulation. e.g. `println(s"Process $self delivers message $msg");`  
/// 5. Remember that during the simulation check you can print and observe the simulation time, i.e. with `System.currentTimeMillis()`.  
/// 5. Do not forget to run the checker code block after each component implementation to ensure that all properties are satisfied before exporting and submitting the notebook.  

/// Good luck! :)

package se.kth.edx.id2203.templates

import se.kth.edx.id2203.core.ExercisePrimitives._
import se.kth.edx.id2203.core.Ports._
import se.kth.edx.id2203.templates.WaitingCRB._
import se.kth.edx.id2203.validation._
import se.sics.kompics.network._
import se.sics.kompics.sl.{Init, _}
import se.sics.kompics.{ComponentDefinition => _, Port => _, _}

import scala.collection.immutable.Set
import scala.collection.mutable
import scala.collection.mutable._

/**
  * BasicBroadcast implements Best-Effort Broadcast (BEB).
  *
  * When a process receives a BEB_Broadcast event, it sends the message (wrapped as BEB_Broadcast)
  * to every process in the topology using Perfect Links. Upon receiving a message from the PerfectLink,
  * the process delivers it (wrapped as BEB_Deliver) to the upper layer.
  *
  * This implementation satisfies the following properties:
  *   1. Validity: If a correct process broadcasts a message m, every correct process eventually delivers m.
  *   2. No duplication: No message is delivered more than once.
  *   3. No creation: If a process delivers a message m from sender s, then m was previously broadcast by s.
  */
class BasicBroadcast(init: Init[BasicBroadcast]) extends ComponentDefinition {

  // Subscribed ports.
  val pLink = requires[PerfectLink]
  val beb = provides[BestEffortBroadcast]

  // Component state and initialization.
  val (self, topology) = init match {
    case Init(s: Address, t: Set[Address] @unchecked) => (s, t)
  }

  // Handler for BEB_Broadcast events.
  beb uponEvent {
    case BEB_Broadcast(payload) => {
      // Send the message to every process in the topology using Perfect Link.
      for (dest <- topology) {
        trigger(PL_Send(dest, BEB_Broadcast(payload)) -> pLink)
      }
    }
  }

  // Handler for Perfect Link deliveries.
  pLink uponEvent {
    case PL_Deliver(src, BEB_Broadcast(payload)) => {
      // Deliver the broadcast message to the upper layer.
      trigger(BEB_Deliver(src, payload) -> beb)
    }
  }
}


/// ### Part II: Reliable Broadcast

/// A Reliable Broadcast Abstraction (RB), in Kompics terms, is a component that **provides** the following port _(already imported in the notebook)_.

/// ```
/// class ReliableBroadcast extends Port {
/// indication[RB_Deliver];
/// request[RB_Broadcast];
/// }
/// ```
/// 
/// An **RB** component should request `RB_Broadcast` and indicate `RB_Deliver` events, as defined below:
/// 
/// ```
/// case class RB_Deliver(source: Address, payload: KompicsEvent) extends KompicsEvent;
/// case class RB_Broadcast(payload: KompicsEvent) extends KompicsEvent;
/// ```
/// 
/// As you have already learnt from the course lectures, Reliable Broadcast adds the `Agreement` property into the already existing properties of Best-Effort Broadcast:
/// 
/// 1.  Validity: _If a correct process broadcasts a message m, then every correct process eventually delivers m._
/// 2.  No duplication: _No message is delivered more than once._
/// 3.  No creation: _If a process delivers a message m with sender s, then m was previously broadcast by process s._
/// 4.  **Agreement**: _If a message m is delivered by some correct process, then m is eventually delivered by every correct process._
/// 
/// HINT: The recommended algorithm to use in this assignment is _Eager Reliable Broadcast_ and is described in page 2 within the following [document](https://d37djvu3ytnwxt.cloudfront.net/assets/courseware/v1/6c144fd806b3568f6e2c5d7d03e27a29/asset-v1:KTHx+ID2203.1x+2016T3+type@asset+block/reliablebroadcast.pdf) in the respective lecture.
/// 
/// **Mind that, to complete this part, you will first have to implement and test Best-Effort Broadcast, defined above.**
class EagerReliableBroadcast(init: Init[EagerReliableBroadcast]) extends ComponentDefinition {
  // Subscribed ports.
  val beb = requires[BestEffortBroadcast]
  val rb = provides[ReliableBroadcast]

  // Component state: our own address and a set to track delivered payloads.
  val self = init match {
    case Init(s: Address) => s
  }
  val delivered = mutable.Set[KompicsEvent]()

  // Handler for RB_Broadcast events coming from the upper layer.
  rb uponEvent {
    case x @ RB_Broadcast(_) => {
      trigger(BEB_Broadcast(RB_Broadcast(x.payload)) -> beb)
    }
  }

  // Handler for BEB-delivered messages.
  beb uponEvent {
    case BEB_Deliver(src, y @ RB_Broadcast(payload)) => {
      if (!delivered.contains(payload)) {
        delivered += payload
        trigger(RB_Deliver(src, payload) -> rb)
        trigger(BEB_Broadcast(y) -> beb)
      }
    }
  }
}

//Causal Reliable Broadcast
//Declare custom message types related to internal component implementation
object WaitingCRB {

  case class DataMessage(timestamp: VectorClock, payload: KompicsEvent) extends KompicsEvent;
}

/// ### Part III: Causal-Order Reliable Broadcast
/// 
/// A Causal-Order Reliable Broadcast Abstraction (CRB), in Kompics terms, is a component that **provides** the following port _(already imported in the notebook)_.
/// 
/// ```
/// class CausalOrderReliableBroadcast extends Port {
///  indication[CRB_Deliver];
///  request[CRB_Broadcast];
/// }
/// ```
/// 
/// A **CRB** component should request `CRB_Broadcast` and indicate `CRB_Deliver` events, as defined below:
/// 
/// ```
/// case class CRB_Deliver(src: Address, payload: KompicsEvent) extends KompicsEvent;
/// case class CRB_Broadcast(payload: KompicsEvent) extends KompicsEvent;
/// ```
/// 
/// As you have already learnt from the course lectures, Causal-Order Reliable Broadcast adds the `Causal Delivery` property into the already existing properties of Reliable and Best-Effort Broadcast:
/// 
/// 1.  Validity: _If a correct process broadcasts a message m, then every correct process eventually delivers m._
/// 2.  No duplication: _No message is delivered more than once._
/// 3.  No creation: _If a process delivers a message m with sender s, then m was previously broadcast by process s._
/// 4.  Agreement: _If a message m is delivered by some correct process, then m is eventually delivered by every correct process._
/// 5.  **Causal delivery**: _For any message m1 that potentially caused a message m2, i.e., m1 → m2, no process delivers m2 unless it has already delivered m1._
/// 
/// HINT: The recommended algorithm to use in this assignment is _Waiting Causal Broadcast_ and is described in page 4 within the following [document](https://d37djvu3ytnwxt.cloudfront.net/assets/courseware/v1/f11d45d4cb0d9685c723dd00de427b8d/asset-v1:KTHx+ID2203.1x+2016T3+type@asset+block/causalbroadcast.pdf) in the respective lecture.
/// 
/// **Also mind, that to complete this part, you will first have to implement and test Best-Effort Broadcast and Reliable Broadcast, defined above.**
/// 
/// #### Working with Vector Clocks
/// 
/// We have already provided you a `VectorClock` data structure **(already imported)** to aid you with the algorithm implementation. You can briefly see the supported operations below:
/// 
/// ```
///  case class VectorClock(var vc: Map[Address, Int]) {
///   def inc(addr: Address) : Unit  //increases the clock corresponding to the address @addr provided
///   def set(addr: Address, value: Int) : Unit //sets the clock of @addr to @value
///   def <=(that: VectorClock): Boolean   //returns true if this vector clock instance is lower or equal to @that
///  }
///  object VectorClock {
///    def empty(topology: scala.Seq[Address]): VectorClock //generates a vector clock that has an initial clock value of 0 for each address in the @topology provided
///    def apply(that: VectorClock): VectorClock //copy constructor of a vector clock. E.g. if vc1 is a vector clock vc2 = VectorClock(vc1) is a copy of vc1
///  }
/// ```
/// 
/// In case you want to check the full implementation of the VectorClock, you can find it in our full published gist [here](https://gist.github.com/senorcarbone/5c960ee27a67ec8b6bd42c33303fdcd2).
class WaitingCRB(init: Init[WaitingCRB]) extends ComponentDefinition {

  // Subscribed ports: we require ReliableBroadcast (RB) and provide CausalOrderReliableBroadcast (CRB).
  val rb = requires[ReliableBroadcast];
  val crb = provides[CausalOrderReliableBroadcast];

  // Component state: our own address and a vector clock with an entry for every process in the topology.
  // Note that we do NOT update our local clock when broadcasting.
  val (self, vec) = init match {
    case Init(s: Address, t: Set[Address] @unchecked) => (s, VectorClock.empty(t.toSeq))
  };

  // A buffer for messages delivered by RB but not yet deliverable in causal order.
  var pending: ListBuffer[(Address, DataMessage)] = ListBuffer();
  var lsn = 0;

  /**
    * deliverable(msg, src)
    *
    * Determines whether the message (with its attached vector clock) can be delivered,
    * i.e., whether its causal dependencies are satisfied.
    *
    * For a message from any process p, the condition is:
    *   (a) msg.timestamp(p) == vec(p) + 1, and
    *   (b) For every other process q, msg.timestamp(q) <= vec(q).
    */
  def deliverable(msg: DataMessage, src: Address): Boolean = {
    // Check the conditions for each process in the topology.
    for (p <- vec.vc.keys) {
      if (p == src) {
        if (msg.timestamp.vc.getOrElse(p, 0) != vec.vc.getOrElse(p, 0) + 1) {
          return false;
        }
      } else {
        if (msg.timestamp.vc.getOrElse(p, 0) > vec.vc.getOrElse(p, 0)) {
          return false;
        }
      }
    }
    return true;
  }

  def tryDeliverPending(): Unit = {
    var progress = true
    while (progress) {
      val (deliverableMsgs, notYet) = pending.partition { case (src, msg) =>
        deliverable(msg, src)
      }
      if (deliverableMsgs.nonEmpty) {
        deliverableMsgs.foreach { case (src, msg) =>
          // Update the vector clock from the delivered message.
          vec.inc(src)
          
          trigger(CRB_Deliver(src, msg.payload) -> crb)
        }
        pending = ListBuffer() ++ notYet
        progress = true
      } else {
        progress = false
      }
    }
  }

  //////////////////// CRB Event Handlers ///////////////////////

  // Handler for CRB_Broadcast requests coming from the upper layer.
  crb uponEvent {
    case x: CRB_Broadcast => {
      // Instead of immediately incrementing our local vector clock, create a copy and increment in the copy.
      // This copy will be attached to the message, while our local clock remains unchanged until delivery.
      var w = VectorClock(vec.vc);  // copy of the current vector clock
      lsn = lsn + 1; 
      w.set(self, lsn); 
      val dmsg = DataMessage(w, x.payload);
      trigger(RB_Broadcast(dmsg) -> rb);
    }
  }

  // Handler for messages delivered from the Reliable Broadcast layer.
  rb uponEvent {
    case x @ RB_Deliver(src: Address, msg: DataMessage) => {
      pending += ((src, msg));
      tryDeliverPending();
    }
  }
}

object BroadcastCheck extends App  {
    // NOTE: this exercise has 3 parts, during development feel free to comment out individual checks.
    // For submission, all checks need to pass.
    checkBEB[BasicBroadcast]();
    checkRB[BasicBroadcast,EagerReliableBroadcast]();
    checkCRB[BasicBroadcast, EagerReliableBroadcast, WaitingCRB]();
}